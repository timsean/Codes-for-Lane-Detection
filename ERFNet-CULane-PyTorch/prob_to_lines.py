from PIL import Image,ImageDraw, ImageFilter, ImageColor, ImageOps
from erf_settings import *
import numpy as np
import matplotlib.pyplot as plt
import cv2

# Alternative to matlab script that converts probability maps to lines
YS = IN_IMAGE_H - np.arange(POINTS_COUNT) * 20 - 1

def GetLane(score, thr = 0.3):

    coordinate = np.zeros(POINTS_COUNT)
    for i in range (POINTS_COUNT):
        lineId = int(TRAIN_IMG_H - i * 20 / IN_IMAGE_H_AFTER_CROP * TRAIN_IMG_H - 1)
        line = score[lineId, :]
        max_id = np.argmax(line)
        max_values = line[max_id]
        if max_values / 255.0 > thr:
            coordinate[i] = max_id

    coordSum = np.sum(coordinate > 0)
    if coordSum < 2:
        coordinate = np.zeros(POINTS_COUNT)

    return coordinate, coordSum


def GetLines(existArray, scoreMaps, thr = 0.3):
    coordinates = []

    for l in range(len(scoreMaps)):
        if (existArray[l]):
            coordinate, coordSum = GetLane(scoreMaps[l], thr)

            if (coordSum > 1):
                xs = coordinate * (IN_IMAGE_W / TRAIN_IMG_W)
                xs = np.round(xs).astype(np.int)
                pos = xs > 0
                curY = YS[pos]
                curX = xs[pos]
                curX += 1
                coordinates.append(list(zip(curX, curY)))
            else:
                coordinates.append([])
        else:
            coordinates.append([])

    return coordinates

def AddMask(img, mask, color, threshold = 0.3):
    back = Image.new('RGB', (img.size[0], img.size[1]), color=color)

    alpha = np.array(mask).astype(float) / 255
    alpha[alpha > threshold] = 1.0
    alpha[alpha <= threshold] = 0.0
    alpha *= 255
    alpha = alpha.astype(np.uint8)
    mask = Image.fromarray(np.array(alpha), 'L')
    mask_blur = mask.filter(ImageFilter.GaussianBlur(3))

    res = Image.composite(back, img, mask_blur)
    return res

def AddLinesPts(img, coords, color):
    base = ImageDraw.Draw(img)

    for i in range(0,4):
        if coords[i]:
            for pt in coords[i]:
                base.ellipse((pt[0], pt[1], pt[0]+10, pt[1]+10), fill=color, outline=(0,0,0))

    return 0

# Experiment name
exp = 'vgg_SCNN_DULR_w9'
# Data root
data = './data/CULane'
# Directory where prob imgs generated by CNN are saved.
probRoot = './predicts/' + exp
# Directory to save fitted lanes.
output = './output/' + exp

testList = data + '/list/test.txt'

with open(testList) as file:
    test_fnames = [line.rstrip('\n') for line in file]
num = len(test_fnames)

plt.ion()
num=1
for i in range(0,num):
    if i%100 == 99:
        print('Processing the {0} the image'.format(i+1))

    test_fname = test_fnames[i] # The test image
    print(test_fname)
    test_img = cv2.imread(data + test_fname)
    test_img = cv2.cvtColor(test_img, cv2.COLOR_BGR2RGB)

    exist_fname = probRoot + test_fname[0:-3] + 'exist.txt' # Txt file indicating existance of lanes
    with open(exist_fname) as file:
        exist = file.read().split(' ')[0:4]
    exist = [int(e) for e in exist] 

    # Get the coordinates of each lane that exists
    scoreMaps = [None, None, None, None]
    masked_img = Image.fromarray(test_img)
    for j in range(0,4):
        if exist[j] == 1:
            score_fname = probRoot + test_fname[0:-4] + '_' + str(j+1) + '_avg.png'
            scoreMaps[j] = cv2.imread(score_fname, 0).astype(np.uint8)
            # resizing breaks GetLane function
            #scoreMaps[j] = cv2.resize(scoreMaps[j], (IN_IMAGE_W, IN_IMAGE_H_AFTER_CROP), interpolation=cv2.INTER_LINEAR)
            #masked_img = AddMask(masked_img, cv2.copyMakeBorder(scoreMaps[j], VERTICAL_CROP_SIZE, 0, 0, 0, cv2.BORDER_CONSTANT, value=[0,0,0]), 'Green')
            
    coordinates = GetLines(exist, scoreMaps)
    AddLinesPts(masked_img, coordinates, 'Green')
    plt.imshow(masked_img)
    plt.draw()
    plt.pause(0.0333)
    plt.clf()
    